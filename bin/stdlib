comment () 
{ 
    : since the DECLARE -F idiom eats;
    : date: 2018-02-16;
    echo $* 1>&2
}
ignore () 
{ 
    : ~ cmmd args ...;
    : returns STATUS, but not STDOUT;
    : trace_callstack;
    : app_trace $*;
    : date: 2019-11-23;
    $@ > /dev/null
}
quietly () 
{ 
    : ~ cmmd args ...;
    : returns STATUS, but not STDERR;
    : date: 2018-02-16;
    : date: 2018-10-09;
    $@ 2> /dev/null
}
report_copyright () 
{ 
    : date: 2019-04-22;
    comment "Copyright (C) 2015-2019, JYATL - Just Yet Another Testing Lab";
    email_comment
}
report_emptyfile () 
{ 
    [[ -s $1 ]] && return 1;
    report_usage File: $1 is empty
}
report_init () 
{ 
    : app_trace $*;
    return;
    fam_iam;
    assert_init
}
report_isdirectory () 
{ 
    [[ -d $1 ]] || return 1;
    report_usage $1 IS a directory and should not be ${*:2}
}
report_isfile () 
{ 
    [[ -f $1 ]] || return 1;
    report_usage $1 IS a file and should not be ${*:2}
}
report_isfunction () 
{ 
    : date: 2018-08-10;
    declare -f $1 > /dev/null || return 1;
    report_usage $1 IS a Function ${*:2}
}
report_nofilefrom () 
{ 
    : date: 2018-02-16;
    set $(eval $*) /dev/null $*;
    [[ -f $1 ]] && return 1;
    shift;
    report_usage \'$*\' did not return a file name.
}
report_notargcount () 
{ 
    : date: 2018-02-16;
    [[ $2 -ge $1 ]] && return 1;
    report_usage need at least $1 arg/s: ${*:3}
}
report_notbase () 
{ 
    : date: 2017-05-12;
    : date: 2018-02-16;
    [[ $(basename $PWD) == "$1" ]] && return 1;
    comment change to "$1" directory
}
report_notblockspecial () 
{ 
    [[ -b $1 ]] && return 1;
    report_usage $1 "ISN'T" a blockspecial file
}
report_notcalledby () 
{ 
    set ${1:-/dev/null} $(myname 3) non-Existant-function;
    [[ $2 == $1 ]] && return 1;
    report_usage "WASN'T" called by $1.
}
report_notcharacterspecial () 
{ 
    [[ -c $1 ]] && return 1;
    report_usage $1 "ISN'T" a characterspecial file
}
report_notcommand () 
{ 
    : date: 2018-02-16;
    type -a $1 > /dev/null 2> /dev/null && return 1;
    report_usage $1 "ISN'T" a command
}
report_notcurrentdirectory () 
{ 
    : date: 2018-02-16;
    : date: 2018-10-09;
    : date: 2019-11-23;
    [[ "$PWD" == "$1" ]] && return 1;
    report_usage $1 "ISN'T" $PWD ${@:2}
}
report_notdirectory () 
{ 
    : date: 2018-02-16;
    : date: 2018-10-09;
    [[ -d $1 ]] && return 1;
    report_usage $1 "ISN'T" a Directory ${@:2}
}
report_notexactcount () 
{ 
    [[ $2 -eq $1 ]] && return 1;
    report_usage need exactly $1 arg/s: ${*:3}
}
report_notexecutable () 
{ 
    [[ -x $1 ]] && return 1;
    report_usage $1 "ISN'T" an executable file
}
report_notexisting () 
{ 
    [[ -e $1 ]] && return 1;
    report_usage $1 "ISN'T" an existing file
}
report_notfile () 
{ 
    : date: 2018-02-16;
    [[ -f $1 ]] && return 1;
    report_usage $1 "ISN'T" a file
}
report_notfile_gt_zero () 
{ 
    [[ -s $1 ]] && return 1;
    report_usage $1 "ISN'T" a filegreaterthanzero
}
report_notfilegreaterthanzero () 
{ 
    : date: 2018-02-16;
    [[ -s $1 ]] && return 1;
    report_usage $1 "ISN'T" a filegreaterthanzero
}
report_notfunction () 
{ 
    : returns: TRUE when 1st arg "ISN'T" a function,;
    : ... FALSE if it IS a function;
    : date: 2018-02-16;
    declare -f $1 > /dev/null && return 1;
    report_usage $1 "ISN'T" a function
}
report_notgroup () 
{ 
    [[ -G $1 ]] && return 1;
    report_usage $1 "ISN'T" a file with group or egid
}
report_notgroupiseuid () 
{ 
    : date: 2018-02-16;
    [[ -G $1 ]] && return 1;
    report_usage $1 "ISN'T" a file with groupiseuid
}
report_notlargeenough () 
{ 
    : date: 2018-02-16;
    [[ $2 -ge $1 ]] && return 1;
    report_usage $1 $(echo 1: $1, 2: $2 3...: ${*:3})
}
report_notlib () 
{ 
    : date: 2018-01-29;
    : date: 2018-02-13;
    : date: 2018-02-16;
    [[ $(functions ${1:-MissingFirstArgument} | grep _init$ | wc -l) -gt 0 ]] && return 1;
    report_usage $1 "ISN'T" a shell function library
}
report_notmodifiedsinceread () 
{ 
    [[ -N $1 ]] && return 1;
    report_usage $1 "ISN'T" modified since last READ
}
report_notnonzerostring () 
{ 
    [[ -n $1 ]] && return 1;
    report_usage $1 "ISN'T" a nonzerolengthstring
}
report_notowner () 
{ 
    [[ -O $1 ]] && return 1;
    report_usage $1 "ISN'T" a file with owner or euid
}
report_notowneriseuid () 
{ 
    : date: 2018-02-16;
    [[ -O $1 ]] && return 1;
    report_usage $1 "ISN'T" a file with owneriseuid
}
report_notpipe () 
{ 
    : returns: TRUE when STDIN "ISN'T" a pipe;
    : ... FALSE if stdin is a pipe;
    : date: 2018-02-16;
    [[ -p /dev/stdin ]] && return 1;
    report_usage "ISN'T" reading a pipe
}
report_notreadable () 
{ 
    [[ -r $1 ]] && return 1;
    report_usage $1 "ISN'T" a readable file
}
report_notsetgroupid () 
{ 
    [[ -g $1 ]] && return 1;
    report_usage $1 "ISN'T" a file with setgroupid
}
report_notsetuserid () 
{ 
    [[ -u $1 ]] && return 1;
    report_usage $1 "ISN'T" a file with setuserid
}
report_notsocket () 
{ 
    [[ -S $1 ]] && return 1;
    report_usage $1 "ISN'T" a socket
}
report_notstickybitset () 
{ 
    [[ -k $1 ]] && return 1;
    report_usage $1 "ISN'T" a file with its stickybitset
}
report_notsymboliclink () 
{ 
    [[ -L $1 ]] && return 1;
    report_usage $1 "ISN'T" a symboliclink
}
report_notterminal () 
{ 
    case $1 in 
        [0-9])
            [[ -t $1 ]] && return 1;
            report_usage $1 "ISN'T" a TERMINAL
        ;;
        *)
            report_usage $1 is not in range 0 - 9
        ;;
    esac
}
report_nottrue () 
{ 
    : date: 2017-07-18;
    : date: 2018-02-16;
    eval "$@" && return 1;
    report_usage $@ FAILED
}
report_notwritable () 
{ 
    [[ -w $1 ]] && return 1;
    report_usage $1 "ISN'T" a writable file
}
report_notzerolengthstring () 
{ 
    [[ -z "$1" ]] && return 1;
    report_usage $1 "ISN'T" a zerolengthstring
}
report_source () 
{ 
    : mfg: report_locality;
    : date: 2018-03-12;
    ${@:-echo} /Users/martymcgowan/git/bash/shelf
}
report_usage () 
{ 
    : writes: usage message of report_... caller FAILURE to STDERR;
    : date: 2018-03-30;
    echo USAGE $(myname 3): $* 1>&2
}
shd_all () 
{ 
    : date: 2018-11-05;
    report_notfile "${1:-Missing Function Libary}" && return 1;
    foreach shd_one $(functions $*)
}
shd_clean () 
{ 
    : removes empty doc strings from stdin;
    : 2019-01-28 using canonical { declare -f } format for doc;
    report_notpipe && return 1;
    awk '
        !NF         { next }
        #
        NF == 2 && $2 ~ /[(][)]/ { lcount = 0 }
        #                         
                    { line[lcount++] = $0; }

        #  template:
        #  0: name ()
        #  1: {
        #  i: ...
        #  N: }   
        lcount < 3  { next; }

        lcount == 3 { if( $1 ~ /^}$/ ) { lcount = 0; next; }
                      else             { print line[0]; print line[1]; }
                    }
                    # printf "DEBUG: lc(%d): %s\n", lcount, $0 > "/dev/stdout"; }
                    { print line[lcount-1] }
      '
}
shd_copyright () 
{ 
    : date: 2019-04-22;
    comment "Copyright (C) 2016-2019, JYATL - Just Yet Another Testing Lab";
    email_comment
}
shd_demo () 
{ 
    shdoc $(sfg shd_)
}
shd_entry () 
{ 
    : date: 2020-01-23;
    ${*:-echo} shd_entry shdoc shd_oc shd_abstract shd_all shd_copyright shd_demo shd_history shd_latest shd_mydoc_case shd_mydoc_notfunction shd_setdate shd_tagnames shd_summary shd_test
}
shd_getdate () 
{ 
    : date: 2016-10-01;
    : test for file arguments;
    : collect date-stamps from functions, by args;
    : 0 -- all functions;
    : N -- library ... function ...;
    : date: 2017-03-11;
    : add RE to allow date: field;
    : date: 2018-01-17;
    : date: 2018-02-16;
    : app_trace $*;
    : date: 2019-05-30;
    { 
        case $# in 
            0)
                set
            ;;
            *)
                fun_allbody ${*:--}
            ;;
        esac
    } | awk ' 	    
        $2 ~ /^\(\)$/     { fun = $1 } 

        $1 ~ /^:$/ && $2 ~ /^date:*$/ {

                             printf "%s\t%s\n", fun, $0
			  }
    '
}
shd_history () 
{ 
    : list LAST_CHANGEDATE FUNCTION for each function in Environment;
    : date: 2019-03-24;
    set | shd_getdate | awk ' { sub(/;/, "", $4); printf "%s\t%s\n", $4, $1 }' | sort -r | awk '!p[$2]++ { print }'
}
shd_justcolon () 
{ 
    : returns leading colon-comments from a SINGLE function;
    report_notpipe && return 1;
    awk '
    NR > 2 {
             if ( $1 !~ /^:/ ) exit
             else              print
           }
    '
}
shd_latest () 
{ 
    : date: 2016-10-16;
    : uses: shd_getdate awk;
    : date: 2018-01-17;
    : date: 2018-02-16;
    shd_getdate $* | awk '

        { sub(/;/,"", $4); date[$1] = $4 };
    END { for (d in date) print date[d], d; }

    '
}
shd_mydoc () 
{ 
    : retreive the comment header of the Calling Function;
    : .. myname 2.., most likely due to a detected error;
    : date: 2019-11-23;
    set -- $(myname 2);
    report_notfunction $1 && return 1;
    { 
        printf "\nFUNCTION\t$1\n";
        declare -f $1 | shd_justcolon
    } 1>&2
}
shd_mydoc_case () 
{ 
    : this is a test of shd_mydoc. One Argument is required;
    : the calling functions comment header is returned;
    : date: 2019-11-23;
    report_notfunction ${1:-/dev/null} && { 
        shd_mydoc;
        return 1
    };
    printf "=====\n%s\n" "this argument: $1 IS a Function"
}
shd_mydoc_notfunction () 
{ 
    : testcase for shd_mydoc not function;
    : this function requires a FUNCTION for its first Argument;
    report_notfunction $1 && { 
        shd_mydoc;
        return 1
    };
    printf "\nthis function $(myname) received a FUNCTION Arugment: $1\n" 1>&2
}
shd_oc () 
{ 
    : makes conventional name for shdoc in SHD family;
    shdoc ${*:-$(myname) shdoc}
}
shd_one () 
{ 
    : date 2017-02-09;
    : this is a shell doclib "shdoc" comment;
    : --------------------------------------;
    : an shdoc comment is the first ":"-origin lines;
    : in the shell function, the rest being the executable.;
    : writes a function {name}_doc for function "name";
    : note: "function NAME_doc () {" is a sticky format.;
    : uses: shd_trim;
    : date: 2018-02-16;
    report_notfunction $1 && return 1;
    printf "function %s_doc () {\n" $1;
    shd_trim $1;
    echo "}"
}
shd_setdate () 
{ 
    : appends date tag to function, avoiding redundancy;
    : as last line among leading shdoc comments;
    : -----;
    : this uses the local function trick. trailing UNSET;
    : date: 2016-09-30;
    : update: change date from comment to shd_ tag;
    : uses: awk declare foreach fun_allnames uniq;
    : args: .. function .. library ..;
    : stdout: function_body ...;
    : date: 2018-01-17;
    : date: 2018-02-16;
    function _dffx () 
    { 
        declare -f $1 | awk -v date=$(date +%F) '

        BEGIN       { code = 0 }

        NR < 3 || ( \
        NR > 2 && !code && $1 ~ /^:$/ \
	          ) {
	              print; next
		    }
        !code       {
	              printf "    : date: %s;\n", date
		      code = 1
		    }
		    { print }

     ' | uniq | tee .$(myname).out
    };
    : app_trace $*;
    foreach _dffx $(fun_allnames ${*:-shd_setdate});
    unset _dffx
}
shd_summary () 
{ 
    for fun in $*;
    do
        isfunction $fun || continue;
        printf "\n----\t$fun\n";
        declare -f $fun | sh_lcolon | grep -v ": date: ....-..-..;$";
    done
}
shd_tagnames () 
{ 
    : date: 2017-04-19;
    report_notfunction $1 && return 1;
    shd_tags $* 2> /dev/null | field 2 | sort -u
}
shd_tags () 
{ 
    : args: function ...;
    : format: function tag-line;
    : uses: shd_oc awk;
    shd_oc ${*:-$(myname)} | awk '

        $1 ~ /^function$/ { name = $2; sub(/_doc$/,"",name); }
	$2 ~ /:$/         {
           tag = $0
	   sub(/: /,"",tag)
   	   sub(/: /,"\t",tag)
      	   sub(/;$/,"",tag)
	   printf "%-9s\t%s\n", name, tag
        }
	'
}
shd_test () 
{ 
    : 1. test default, NO arguments, then;
    : 2. stub out test all functions in the library;
    : 3. demonstrate ignore subsequent comments;
    : 4. test shd_clean;
    rm -f .shd*;
    set .shd{oc,clean};
    shdoc;
    :;
    shdoc $(sfg shd_) | tee $1 | shd_clean | tee $2;
    declare -f shd_test | grep -v '^ *:' 1>&2;
    wc $*;
    comm -23 <(functions $1|sort) <(functions $2|sort)
}
shd_trim () 
{ 
    : ~ function;
    : user function to trim candidate comments;
    set ${*:-$(myname)};
    report_notfunction $1 && return 1;
    declare -f $* | awk ' $1 !~ /^:[;]*$/'
}
shdoc () 
{ 
    : this is a shell doclib "shdoc" comment;
    : an shdoc comment is the first ":"-origin lines;
    : in the shell function, the rest being the executable.;
    : date: 2019-01-28 use local _shdoc and produce declare -f format;
    function _shdoc () 
    { 
        : date: 2018-02-16;
        report_notfunction $1 && return 1;
        echo "function ${1}_doc {";
        declare -f $1 | shd_justcolon;
        echo "}"
    };
    foreach _shdoc ${*:-$(myname)}
}
isfunction () 
{ 
    : ~ function;
    : returns TRUTH of argument as FUNCTION;
    declare -f ${1:-/dev/null} > /dev/null
}
report_init 1>&2
