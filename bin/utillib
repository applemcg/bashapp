proc_parent_test () 
{ 
    : test both facets of proc_parent: terminal shell or SCRIPT?;
    : date: 2020-02-03;
    set -- ./proc_bash proc_parent;
    echo FUNCTION $($2);
    echo =====;
    printf "#! /usr/bin/env bash\n%s\n%s\n" "$(qf $2)" $2 > $1;
    chmod +x $1;
    echo SCRIPT $($1);
    echo =====;
    echo the function;
    qf $(myname) | sed 's/^/    /';
    echo ----;
    echo the script:;
    sed 's/^/    /' $1
}
app_isa () 
{ 
    : encourage FUNCTIONS to Become an APP;
    : usage: "app_isa arg ... || return";
    : caller may have an _INIT function, if so, call it;
    : also, if CALLER_$1 is a function, call it with args, and return;
    : and, if the first argument is NOT a function and;
    : if there is a MAIN function, call it;
    : internal -- parent_subfunction, FUNC return failure = 1.;
    : to allow parent a default behavior of its own.;
    : date: 2020-01-27;
    : date: 2020-02-02 add default _MAIN function;
    local parent=$(proc_parent $(myname 2));
    :;
    : ------------------------------------------------------ any initialization --;
    local init=${parent}_init;
    isfunction $init && $init 2> /dev/null;
    :;
    : -------------------------------------------------- any user customization --;
    : --------- has to be an executable, not a function --;
    :;
    local user=$(which ${parent}_user);
    [[ -f "$user" ]] && $user;
    :;
    : ------------------------------------------------------- a PARENT_function --;
    : -------------------- is the first arg: PARENT arg --;
    local func=${parent}_$1;
    isfunction $func && { 
        shift;
        $func $*;
        return 1
    };
    : ------------------------------------------------------ implicit functions --;
    case $1 in 
        help)
            : ----------------------- this is the default help function --;
            :;
            : a user-defined parent_help overrides by calling "parent help";
            sfg ${parent}_ | pr -t4 1>&2;
            return 1
        ;;
        *)
            : ------------------- main is surrogate for no sub-function --;
            :;
            local main=${parent}_main;
            isfunction $main && { 
                $main "$@";
                return 1
            };
            comment NOT Help, PARENT: $parent, args: $*;
            ( printf "$parent %s\n" "[ help |";
            printf "$(app_kids ${parent}_ | pr -t4 | sed 's/^/        /') \n]\n" ) 1>&2
        ;;
    esac
}
f2file () 
{ 
    : copy librarys Functions inTO separate FILEs;
    : need NOT be run from librarys home.;
    : enables spilling older definitions without;
    : overwriting current function definitions.;
    : date: 2017-07-10;
    : date: 2020-02-04 save DIRECTORY in home/lib;
    report_notfile ${1:-MissingFirstArgument} && return 1;
    set -- $1 $(home)/lib/$(basename $1).d $(awk_file);
    : app_trace $*;
    if [ -d $2 ]; then
        rm -f $2/*;
    else
        mkdir $2;
    fi;
    : app_trace $*;
    grep -v '_init 1>&2$' $1 | awk -v dir=$2 -f $3 2> ~/tmp/f2file_$$.err;
    echo $2
}
proc_parent () 
{ 
    : which are we running, a terminal shell or a SCRIPT?;
    : date: 2020-02-03;
    case $0 in 
        -bash)
            echo ${1:-$(myname 2)}
        ;;
        *)
            basename $0
        ;;
    esac
}
runfrom () 
{ 
    : usage: ~ DIRECTORY function args OR return;
    : date: 2019-09-10;
    : date: 2020-02-04 simplify, test using indir;
    : app_trace ENTERING: $PWD, $*;
    [[ $PWD = $(indir $1 pwd) ]] && return;
    : app_trace HUNTING: $PWD, DIR: $1.;
    ignore pushd $1;
    shift;
    local cmd=$(myname 2);
    : app_trace RUNNING: $PWD, cmd: $cmd, $#: $@;
    $cmd $@;
    : app_trace HAVE RUN: $PWD, $#: $@;
    ignore popd;
    : app_trace POPPED: $PWD, $#: $@;
    cdx 1>&2;
    : dapp_trace CLEARED: $PWD, $#: $@;
    return 1
}
setenv () 
{ 
    : ~ NAME value ...;
    : exports NAME to the environment,;
    : set to value ...;
    : date: 2017-08-23;
    : date: 2018-02-16;
    [[ $# -lt 1 ]] && return;
    local na=$1;
    shift;
    eval $na=\"$*\";
    export $na
}
app_pause () 
{ 
    trace_sub $@
}
app_trace () 
{ 
    : report the CALLER name 0, its args, their caller 1, and the callers caller 2.;
    : date: 2019-05-04;
    : date: 2020-04-23;
    local call_0="";
    local call_1="";
    local call_2="";
    local cdepth=${#FUNCNAME[@]};
    [[ $cdepth -gt 1 ]] && call_0=${FUNCNAME[1]};
    [[ $cdepth -gt 2 ]] && call_1=${FUNCNAME[2]};
    [[ $cdepth -gt 3 ]] && call_2=${FUNCNAME[3]};
    app_pause "CLEAN ME UP $call_0( $* ) $call_1 $call_2"
}
args_uniq () 
{ 
    : date: 2017-03-26;
    : date: 2018-10-29;
    : app_trace $*;
    : date: 2019-08-29;
    awk '
    BEGIN {
	    for (i=1; i < ARGC; i++) {
                 j = ARGV[i];
                 if (!printed[j]++) {
                     printf "%s ", j;
		 }
	     }
	     printf "\n"
	  }
    ' $*
}
awk_file () 
{ 
    : returns file name of awk script;
    : ~ [name {defaulting to calling function, i.e MYNAME 2}];
    : date: 2018-07-30;
    : date: 2018-10-05;
    : date: 2019-09-07 No Relative paths;
    awk_files | grep -v '^\.' | grep /${1:-$(myname 2)}.awk
}
awk_files () 
{ 
    : lists the awk scripts found in a lib,;
    : where "lib" is a sibling directory to a "bin";
    : on the users PATH. see BITMELD;
    : date: 2018-07-30;
    : date: 2018-10-05;
    for lib in $(paths | sed 's/bin$/lib/');
    do
        ls -1 $lib/*.awk;
    done 2> /dev/null
}
cdx () 
{ 
    : removes duplicates from directory stack list;
    : date: 2017-07-10;
    : date: 2018-05-17;
    : date: 2020-03-20 major reorganization;
    :;
    function _cds () 
    { 
        : collect unique directory stack;
        awk '
    	 !p[$0]++ {
            gsub(/\\*  */,"\\ ")
	    line[nr++] = $0
	    }
        END {
	      # pre-decrement since post increment
	      # GT 0 since dirs -c leaves the 0th directory
	      while(--nr > 0) print line[nr]
	    }
    '
    };
    function _esc () 
    { 
        : writes command to quiety tuck each directory down the stack;
        : exposing the stack on completion;
        awk '
        { printf "pushd %s > /dev/null; pushd >/dev/null\n", $0 }
    END { printf "dirs\n" }	
    '
    };
    set -- $(needir ~/tmp)/.{dirs,source};
    dirs -p -l | _cds | tee $1 | _esc > $2;
    dirs -c > /dev/null;
    : clear all but the top of the stack;
    source $2;
    unset _{cds,esc};
    rm -f $1 $2
}
email_comment () 
{ 
    : date: 2019-04-22;
    comment "mailto:edu <dot> MIT {dot} alum {aT} martymcgowan"
}
epoch () 
{ 
    : date: 2017-07-10;
    : date: 2017-07-18;
    : app_trace $*;
    [[ -f $1 ]] || return;
    set $(stat -r $1);
    echo ${10}
}
file_mode () 
{ 
    : return FILEs octal permission;
    : date: 2020-03-22;
    report_notfile ${1:-/dev/null} && return 1;
    set -- $(stat -r $1);
    echo $3
}
for_nomar () 
{ 
    : continue executing first arg as command,;
    : until number of returned arguments is unchanged.;
    : date: 2016-11-10;
    : date: 2019-03-10 isolating the command saves ignoring it in the loop;
    : app_trace $*;
    : date: 2019-08-29;
    local cmmd=$1;
    shift;
    : app_trace CMMD: $cmmd, ARGS: $*;
    while true; do
        local num=$#;
        set $(args_uniq $* $($cmmd $*));
        app_trace AFTER $CMMD "num: $num, $#";
        [[ $num -eq $# ]] && break;
    done;
    : app_trace RETURN $*;
    echo $*
}
foreach () 
{ 
    : ~ command arg ...;
    : executes COMMAND foreach arg ...;
    : date: 2017-05-12;
    : date: 2017-07-16;
    : date: 2019-10-28 QUOTE the ARG;
    report_notargcount 1 $# command ... && return 1;
    for arg in "${@:2}";
    do
        $1 "$arg";
    done
}
fun_alltype () 
{ 
    : returns TAB-separated TYPE of exection object NAME;
    : e.g. function, file, builtin, keyword;
    : date: 2019-08-29;
    printf "%s\t%s\n" $(type -t $1) $1
}
fun_callgraf () 
{ 
    : writes callgraph of function arguments;
    : date: 2018-11-05;
    function app_funcall () 
    { 
        : e.g. foreach app_funcall $* PIPE callgraph;
        : produces pair, calling function called function, from caller.;
        : consolidate function around FUN_USES.;
        : date: 2017-08-16;
        : comment $(myname 3) $(myname 2) "$(myname)( $* )";
        app_funuses $1 | awk "
            \$1 ~ /^$1$/ { next }; 
	    	         { print \"$1\", \$1 }
        "
    };
    report_notargcount 1 $# && return 1;
    rm -f .funuses.out;
    : app_trace foreach app_funcall $*;
    foreach app_funcall $* | tee $(home)/lib/$1.gin | callgraph
}
fun_deparenify () 
{ 
    : separate all "( ... )" sub-expressions;
    : compare and contrast with _subexpr;
    : date 2019-10-10;
    sed 's/[(]/& /g; s/[)]/ &/g' $*;
    unset fun_olddeparenify
}
fun_olddeparenify () 
{ 
    : compare and contrast with _subexpr;
    : date: 2019-09-20;
    sed 's/[(]\([^)]*\)[)]/( \1 )/g' $*
}
fun_starter () 
{ 
    : generate STDERR-directed function calls to any_INIT functions;
    : date: 2018-02-16;
    : date: 2020-03-23 use the INIT functions on all but FUNCIONLIB;
    : todo: MOP this up;
    report_notfile $1 && return 1;
    local cmmd="";
    [[ $1 == functionlib ]] && { 
        cmmd="echo"
    };
    for fun in $(functions $1 | grep _init$ | sort);
    do
        printf "%s %s 1>&2\n" $cmmd $fun;
    done
}
fun_words () 
{ 
    : date: 2019-09-04;
    : date: 2019-09-20;
    declare -f $* | grep -v '^ *: ' | fun_deparenify | tr -s ' \t' '\n' | grep '^[a-zA-Z0-9_]' | sed 's/;$//' | sort -u
}
functions () 
{ 
    : date: 2017-05-29;
    : date: 2017-08-10;
    awk '
         $2 ~ /^[(][)]$/           && \
       ( NF == 2 || $3 ~ /^[{]$/ ) && \
       !printed[$1]++             { print $1 }

    ' ${*:--}
}
home () 
{ 
    : ~ set or fetch the name of the portable File System;
    : intended for DROPBOX, but lets use a portable idea.;
    case $# in 
        0)
            : ${ALT_HOME:-$HOME}
        ;;
        *)
            [[ -d $1 ]] && ALT_HOME=$1
        ;;
    esac;
    export ALT_HOME;
    echo ${ALT_HOME:-$HOME}
}
indir () 
{ 
    : date: 2017-05-29;
    : date: 2018-10-09;
    : app_trace $*;
    report_notdirectory $1 && return 1;
    : app_trace $*;
    pushd $1 > /dev/null;
    : app_trace $*;
    eval ${@:2};
    : app_trace $*;
    popd 1>&2 > /dev/null
}
lib () 
{ 
    : a big fuss over ALT_HOME not in the ENVIRONMENT;
    : todo: see if we can eliminate its use in sh-bang;
    : app_trace home: $(home);
    : app_trace ALT_HOME: ${ALT_HOME};
    ${*:-echo} $(home)/lib
}
llrt () 
{ 
    : list Long, Reverse Time order;
    : date: 2019-04-21 default current directory;
    ls -lrt ${*:-.}
}
max_depth () 
{ 
    : date: 2017-03-05;
    awk -F/ '{ if( NF>max_depth) max_depth=NF } END { print max_depth-1 }'
}
mkdir () 
{ 
    : implements the -p flag by default;
    : date: 2020-03-04;
    function _mkdir () 
    { 
        for f in $*;
        do
            mkdir $f;
        done
    };
    case $1 in 
        -p)
            _mkdir ${*:2};
            return
        ;;
        -v)
            _mkdir ${*:2};
            echo ${*:2};
            return
        ;;
        -m)
            mkdir $3;
            chmod $2 $3;
            return
        ;;
    esac;
    [[ -d $1 ]] && return;
    : app_trace $*;
    mkdir $(dirname $1);
    command mkdir $1;
    unset _mkdir
}
myname () 
{ 
    : ~ [n];
    : returns name of caller OR callers caller ...;
    : date: 2018-02-16;
    echo ${FUNCNAME[${1:-1}]}
}
needir () 
{ 
    : date: 2017-05-29;
    : makes non-existent directory argument and returns name;
    : date: 2018-02-16;
    : date: 2020-03-04;
    report_notargcount 1 $# needed_directory && return 1;
    [[ -d "$1" ]] || mkdir "$1";
    echo "$1"
}
nf () 
{ 
    : date: 2017-05-11;
    : date: 2017-07-18;
    case $1 in 
        *awk)
            AWK=$1;
            shift
        ;;
        *)
            AWK=$( which gawk || which nawk || which awk )
        ;;
    esac;
    case $1 in 
        lt)
            $AWK "NF < ${2:-5}"
        ;;
        gt)
            $AWK "NF > ${2:-1}"
        ;;
        eq)
            $AWK "NF == ${2:-5}"
        ;;
        ne)
            $AWK "NF != ${2:-5}"
        ;;
        help)
            comment $0 "[lt|gt|eq|ne||* [NN]]"
        ;;
        "")
            $AWK NF
        ;;
        *)
            $AWK '{ print NF, $0}'
        ;;
    esac
}
onlyfiles () 
{ 
    : date: 2018-10-09;
    : date: 2019-11-28;
    : date: 2019-11-29;
    for a in $(stdin_orargs ${*:-* .*});
    do
        [[ -f $a ]] && echo $a;
    done
}
paths () 
{ 
    : ~ returns PATH components, a line at a time;
    : date: 2017-05-29;
    : date: 2017-07-16;
    eval echo \$${1:-PATH} | sed 's/::/:.:/' | tr : '\012'
}
sfg () 
{ 
    : date: 2019-12-21 back to our roots, Set Functions Grep;
    set | functions | grep "${@:-.}"
}
stdin_orargs () 
{ 
    : treat STDIN as args, OR echo any args, default to CALLER;
    : date: 2019-03-24;
    : date: 2019-11-29;
    [[ -p /dev/stdin ]] && cat || echo ${*:-$(myname 2)}
}
timestamp () 
{ 
    : ~ fileA fileB;
    : stamp B with TIME of A;
    : date: 2016-10-02;
    : test for file A existing;
    : date: 2018-10-09;
    report_notfile $1 && return 1;
    : app_trace $*;
    touch -t $(date -r $(epoch $1)  +%Y%m%d%H%M.%S) $2
}
type_word () 
{ 
    : date: 2019-11-16;
    report_notfunction ${1:-/dev/null} && return 1;
    foreach fun_alltype $(fun_words $*) | nf gt 1
}
ver_time () 
{ 
    : date: 2017-12-23;
    set -- $(date +%Y%m_%b/%d_%a/%H%M%S);
    : app_trace pwd: $PWD, return: $1;
    echo $1
}
wpl () 
{ 
    report_notpipe && return 1;
    tr -cs 'A-Za-z0-9_' '\n'
}
trace_call () 
{ 
    : obsolescent, retiring in behalf of app_trace;
    : date: 2017-07-18;
    : date: 2018-02-16;
    : date: 2020-04-23;
    trace_stderr "$@"
}
trace_stderr () 
{ 
    : date: 2018-02-16;
    : date: 2020-04-23;
    pa=${FUNCNAME[2]:-COMMANDLINE};
    gr=${FUNCNAME[3]:-COMMANDLINE};
    printf "TRACE %s\t@ %s\t%d  ( %s )\n" "$gr" "$pa" $# "$*" 1>&2
}
pause_on () 
{ 
    : set APP_PAUSE to read with Pause;
    : date: 2019-09-15;
    : date: 2020-04-23;
    eval "app_pause () { : pause execution, displaying the arguments; read -p \"\$@ RETURN?        :\" < /dev/tty >/dev/tty; }"
}
pause_off () 
{ 
    : set APP_PAUSE to STDERR;
    : date: 2019-09-15;
    : date: 2020-04-23;
    eval "app_pause () { trace_sub \$@; }"
}
pause_test () 
{ 
    : date: 2020-04-23;
    function pause_deptha () 
    { 
        pause_on;
        app_trace ON? $1;
        shift;
        pause_off;
        app_trace OFF? $*
    };
    set -- One Two Three Four 5 6;
    pause_on;
    app_trace ON? $1;
    shift;
    pause_off;
    app_trace OFF? $*;
    pause_deptha ${*:3};
    declare -f app_pause pause_{on,off}
}
trace_sub () 
{ 
    : cloned from TRACE_STDERR, to accomodate pause_on, off;
    : also note, stack is one deeper than _STDERR;
    : todo: finds a way to unite these two off-by-one instances.;
    : date: 2018-02-16;
    : date: 2020-04-23;
    pa=${FUNCNAME[3]:-COMMANDLINE};
    gr=${FUNCNAME[4]:-COMMANDLINE};
    printf "%s\n" "$*" 1>&2
}
trace_app () 
{ 
    : tracing, debugging to make an APP;
    : multi-arg eg -- trace_app foreach do_whf;
    : OR trace_app declare -f;
    : date: 2020-04-25;
    ${*:-echo} trace_{call,stderr,sub,app} app_{trace,pause} pause_{on,off}
}
